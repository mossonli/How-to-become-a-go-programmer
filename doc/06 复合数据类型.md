# 复合数据类型

## 数组

> 数据的声明

```go
// 声明一个包含5个元素的数组 [0,0,0,0,0]
var array [5]int 
var array [5]int{10, 20, 30 ,40, 50}
// 声明一个整型数组，用具体的值初始化每一个元素，容量由初始化值的数量决定
array := [...]int{10, 20, 30 ,40, 50}
// 声明一个有5个元素的数组，用具体初始化索引为1和2的元素，其他的保持0
array := [5]int{1:10, 2:30} // [0,10,30,0,0]
---------------------
var a [5]int //[0 0 0 0 0]
b := [5]int{} // [0 0 0 0 0]
var c = [5]int{1, 2, 3, 4, 5}// [1 2 3 4 5]
d := [5]int{1, 3, 4, 5, 6}
```

> 访问和修改

```go
1 // 数组的索引是从0开始
// 循环输出
func main() {
	arr := [5]int{1, 2, 3, 4, 5}
	for i := 0; i<len(arr); i++{
		fmt.Print(i, "== ")
		fmt.Println(arr[i])
	}
}
2 // 修改
// 声明一个包含5个元素的数组
var array [5]int{1, 2, 3, 4, 5}
// 修改索引2的元素值
array[2] = 10
/* 数组的值也可以是指针，使用*运算符就可以访问元素所指的指针 */
array := [5]*int{0:new(int), 1:new(int)} // [0xc00001a0b8 0xc00001a0c0 <nil> <nil> <nil>]
// 为索引0和1的元素赋值
*array[0] = 10
*array[1] = 20
```

> 多维数组

```go
// 4行2列
var array [4][2]int 
```

## 切片

> 创建数组切片[切片的长度不能大于容量]

```go
1 make和切片字面量【使用make函数创建切片，需要传入一个参数指定切片的长度】
// 创建一个字符串切片，气度个容量都是5个元素
slice := make([]string, 5)
// 创建一个整型切片，长度为3，容量为5
slice := make([]int, 3, 5)
利用切片的字面量创建切片(这种方式创建，不需要指定[]中的值，如果指定了就是数组了)
slice := []string{"red", "blue", "green", "pink", "yellow"}
```

> nil和空切片

```go
// 在声明的时候，不做任何初始化，就会创建一个nil切片
// 创建nil整型切片
var slice []int
// 使用make创建一个整型空切片
slice := make([]int, 0)
// 使用切片的字面量,创建一个整型空切片
slice := []int{} 
/*
nil切片在底层数组中包含0个元素，也没有分配任何空间
nil切片还可以用来表示空集合
*/
```

> 切片的使用

```go
1 赋值和分割
//创建一个整型切片，长度容量都是5个元素
slice := []int{10, 20, 30, 40, 50}
// 改变索引1的元素值
slice[1] = 25
//------- 切片之所以被称为切片，是因为创建一个新的切片就是把底层数据切出来一部分。
// 创建一个整型切片长度和容量都是5
slice := []int{10, 20, 30, 40, 50}
// 创建一个新的切片，长度为2，容量为4
newSlice := slice[1:3]
// 使用三个索引进行切片
newSlice2 := slice[2:3:4]
/* 底层数组容量为k的切片slice[i:j:k], 长度为j-i，容量为k-i*/
// -----------
slice := []int{10, 20, 30, 40, 50}
newSlice := slice[1:3]
newSlice[1] = 35
fmt.Println(newSlice) //[20 35]
fmt.Println(slice)[10 20 35 40 50]
2 切片的扩容【使用内置的append()函数】？？？？？？？？？
//创建一个整型切片，长度容量都是5个元素
slice := []int{10, 20, 30, 40, 50}
// 创建一个新的切片，长度为2，容量为4
newSlice := slice[1:3]
// 使用原有的容量分配一个新的元素，将新元素赋值为60
newSlice = append(newSlice, 60)
/*append只能增加新切片的长度，而容量可能变，也可能不变，取决于被操作切片的可用容量*/
3 遍历切片[for range, range返回该位置的索引和对应元素的副本]range是从切片的开头迭代
//创建一个整型切片，长度容量都是5个元素
slice := []int{10, 20, 30, 40, 50}
for index, value := range slice {
  fmt.Printf("index:%d,value:%d\n", index, value)
}
4 切片的容量限制
slice[i:j:k]([2:3:4])，长度为 j-i(即3-2=1)，容量为 k-i(4-2=2)。
//创建一个整型切片，长度容量都是5个元素
source := []int{10, 20, 30, 40, 50}
slice := source[2:3:6] //会报错，原切片最大的索引是5
5 多维切片
slice := [][]int{{10}, {100, 200}}// [[10] [100 200]]
slice[0] = append(slice[0], 20) // [[10 20] [100 200]]
6 将切片传递给函数【在64位的机器上一个切片占24B，指针字段需要8B】

```

> 映射

`在Go语言中映射(map),底层是用hash实现的，Go语言中的映射是一个个的bucket`

```go
1 映射创建
dict := make(map[string]int)//创建映射，键是string类型，值是int类型
// 创建映射，键和值都是string类型，使用两个键值对初始化映射
dict := map[string]string{"Red":"#da1337"，"Orange":"#e95a22"}
2 映射的操作：元素赋值
colors := map[string]string{} //不写make必须要加{} 进行空值初始化
var colors map[string]string //通过声明创建一个nil映射，nil映射不能用来存储键值对
3 查找遍历//在go语言中，通过键来索引映射时，即使这个键不存在，也会返回该值对应的类型的零值
value, exists := colors["blue"]// exists 返回的是True或者False
// 和迭代数组或切片一样，使用关键字range，可以迭代映射里面所有的值，range返回的不是索引和值是键值对
for value := range dict {
		fmt.Println(value) // value 是key
	}
for key, value := range dict {
		fmt.Println(key, value) // 映射的key value
	}
4 元素删除[delete()用于删除容器中的元素]
delete(映射名, key)
```



























