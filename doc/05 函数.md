## Go函数

```html
在Go语言中，函数是指不属于任何结构体、类型的方法，也就是说，函数是没有接收者的;而方法是有接收者的，我们说的方法要么属于一个结构体，要么属于一个新定义的类型。
```

### 函数的声明

```go
func funcNarne(inputl typel, input2 type2) (outputl typel, output2 type2) {
// 逻辑代码
	return valuel, value2 //返回多值
}
/*
func 声明函数
funcName 函数名称
函数名如果是小写字母开头，它的作用域只属于所声明的包，不能被其他的包调用
go函数不支持嵌套、重载、默认参数
*/
```

### 函数的参数

```go
// 函数的参数可以有一个或者多个，每一个参数后面都带有类型，相邻的两个参数是同一个类型可以简略声明: a, b int
```

### 函数的返回值

```go
// 对于多返回值函数，如果不声明变量，也需要指定返回类型。
```

## 函数基础

```html
1 多返回值
2 函数可以作为参数
3 函数可以作为类型***** 不太明白
4 函数的可变参数：函数的最后一个参数如果是 ...type，那么这个函数就是一个变参函数
```

## 匿名函数与闭包

> 匿名函数

```go
fplus := func(x,y int) int {return x+y}
fplus(3, 5)
```

```go
package main
import ("fmt")

func main(){
  func(num, int) int {
    sum := 0
    for i := 1;i <= num; i++ {
      sum += i
    }
    return sum
  }(100) // 这个100 是传给num的
}
```

> 闭包

```go
/*
概念：一个闭包继承了函数声明时的作用域。
这种状态(作用域内的变量)会共享到闭包环境中，因此这些变量可以在闭包中被操作，直到被销毁。
*/
```

## 递归函数

```go
// 概念：运行的过程中调用自身
func recursion(){
  recursion()
}
func main() {
  recursion()
}
// go语言支持递归，但是在使用的时候开发者需要设置推出条件
```

## 内置函数

```go
// 常见的内置函数
close: 用于管道通信
len: 用于返回某一个类型的长度或者是数量(字符串、数组、切片、map和管道)
cap: 容量的意思，返回某一个类型的最大容量(只能用于切片和map)
new、make: 都是用于分配内存(new用户值类型和用户定义类型、make用于引用类型切片、map和管道)
copy、append: 用于复制和连接切片
panic、recover: 用于错误处理
print、println: 底层打印函数,部署环境建议使用fmt
complex、realimag: 用于创建和操作复数
```

## 函数进阶

> 参数的传递机制【值传递和引用传递】

```go
// Go语言默认的是值传递，也就是说传递的是参数的副本，函数接收参数副本以后，使用变量的过程中可能对副本的值进行更改，但是不会影响原来的变量。
// 如果要让函数直接修改参数的值，就需要将参数的地址(&变量名)来传递,这就是引用传递
```

> defer 与跟踪

```go
1 defer 延迟语句
// 函数内部有多个defer语句，当函数执行到最后(return之前)，这些defer会按照“逆序”执行
2 执行顺序【函数中的】
// 多个defer语句的执行顺序为"逆序",defer、return、返回值三者的执行逻辑：defer最先执行一些收尾的工作，然后return执行，return负责将结果写入返回值，最后函数携带当前返回值退出
package main

import "fmt"

func main() {
	fmt.Println("return: ", a())
}

func a() int{
	var i int	//	有名返回值
	defer func() {
		i++
		fmt.Println("defer2:", i)
	}()
	defer func() {
		i++
		fmt.Println("defer1", i)
	}()
	return i 	// 记录i 的值，"逆序执行defer"，所有的defer执行结束，再执行return
}
/*
defer1 1
defer2: 2
return:  0
*/

package main

import "fmt"

func main() {
	fmt.Println("return: ", b())
}

func b() (i int){ // 无名返回值
	defer func() {
		i++
		fmt.Println("defer2:", i)
	}()
	defer func() {
		i++
		fmt.Println("defer1", i)
	}()
	return i
}
/*
defer1 1
defer2: 2
return:  2
*/
// 在defer表达式中，必须是函数调用，意味着ddefer后面不能执行操作语句
```

## 错误与恢复

> error

```go
1 error 接口的实现
type error interface {
  Error() string
}
将error作为返回值中的最后一个返回(并非强制)
func Foo(param int)(n, int, err error) {
  // ....
}
// 调用
func main() {
  n, err := Foo(0)
  if err != nil {
    // 错误处理
  } else {
    // 使用返回值
  }
}
```

> panic



> revover

 