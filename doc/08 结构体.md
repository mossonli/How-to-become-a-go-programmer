## 结构体

`定义`

```go
// 每一个字段都有一个类型和一个名字，在一个结构体中字段必须唯一
type 结构体名 struct {
  
}
type author struct {
  field1 type1
  field2 type2
} 
```

> new 创建结构体

```go
type Student struct {
	id int
	name string
	sex byte
	age int
	addr string
}
func main() {
	// 1 初始化
	var s1 Student = Student{1, "zhangsan", 'f', 19, "sh"}
	fmt.Println(s1)
	// 2 指定某些字段赋值
	var s2 Student = Student{id:2, name:"lsi"}
	fmt.Println(s2)
	// 3 先定义再赋值
	var s3 Student
	s3.id = 3
	s3.name = "wangwu"
	// 4 结构体作为指针变量初始化
	var s4 *Student = &Student{4, "zhaoliu", 'm', 20, "bj"}
	fmt.Println(s4)
	fmt.Println((*s4).id)
	fmt.Println(s4.id) // go 会自动转成 (*s4).id
	// 5 :=
	s5 := Student{5, "xiaoming", 'f', 25, "hk"}
	fmt.Println(s5)
}

结构体在创建之后使用 t := new(T)给该结构体变量分配内存，返回一个已分配内存的指针
func main() {
  type myStruct struct {
		i int
	}
	var v myStruct
	var p *myStruct
	fmt.Println(v, p)
}
表达式new(Type)和&Type{} 是等价的
func main() {
	type Sleep struct {
		start int
		end int
	}
	intr := Sleep{0, 5}
	intr2 := Sleep{end: 5, start: 0}
	intr3 := Sleep{end: 5}
	fmt.Println(intr, intr2, intr3)
}
package main

import (
	"fmt"
	"strings"
)

type Person struct {
	firstName string
	lastName string
}

func upPerson(p *Person)  {
	fmt.Println(p)
	p.firstName = strings.ToUpper(p.firstName)
	p.lastName = strings.ToUpper(p.lastName)
	fmt.Println(p)
	fmt.Println(*p)
}

func main() {
	var pers1 Person
	pers1.firstName = "李"
	pers1.lastName = "si"
	fmt.Println(pers1)
	upPerson(&pers1)
	// 新指针
	pers2 := new(Person) //&{}
	pers2.firstName = "张"
	pers2.lastName =  "sss"
	fmt.Println(pers2) // &{张 sss}
	(*pers2).lastName = "ddd"
	fmt.Println(pers2) // &{张 ddd}
}
```

> 结构体参数

```go
// 结构体可以作为参数传递，值和指针传递是不一样的
type Student struct {
	id int
	name string
	sex byte
	age int
	addr string
}

func tempStu(tmp Student)  {
	tmp.id = 200
	fmt.Println(tmp) // {200 zhangsan 102 19 sh}
}
func tempStu2(tmp *Student)  {
	tmp.id = 300
	fmt.Println(tmp) //&{300 zhangsan 102 19 sh}
}

func main() {
	var s1 Student = Student{1, "zhangsan", 'f', 19, "sh"}
	tempStu(s1)
	fmt.Println(s1) // {1 zhangsan 102 19 sh}
	tempStu2(&s1)
	fmt.Println(s1) //{300 zhangsan 102 19 sh}
}
```

> 结构体的内存结构

```go
// 一个结构体，会占用一段连续的内存空间
type Demo struct {
	A int32
	B int32
	C int32
	D int32
}

func main() {
	var s Demo
	fmt.Printf("A addr:%p\n", &s)
	fmt.Printf("A addr:%p\n", &s.A)
	fmt.Printf("B addr:%p\n", &s.B)
	fmt.Printf("C addr:%p\n", &s.C)
	fmt.Printf("D addr:%p\n", &s.D)
}
A addr:0xc0000140c0
A addr:0xc0000140c0
B addr:0xc0000140c4
C addr:0xc0000140c8
D addr:0xc0000140cc
```

> 构造函数

```go
// go 中并没有构造函数，但是可以自己去实现
// 构造函数是一种特殊的函数，主要用来在创建对象时初始化对象【对象成员变量赋初始值】
type User struct {
	id int
	name string
	age int
}
// 模拟User的构造函数
func NewUser(id int, name string, age int)  *User{
	user := new(User)
	user.id = id
	user.name = name
	user.age = age
	return user
}
```

> 递归结构体

```go

```

> 结构体转换

```go
当给结构体定义一个别名类型时，该结构体与别名类型的底层都是一样的，可以直接转换，不过需要注意，其中由于非法赋值或转换引起的编译错误
type number struct {
	f float32
}
type nr number // 类型别名

func main() {
	a := number{5.0}
	b := nr{5.0}
	var c = number(b)
	fmt.Println(a, b, c)
}
```

## 面向对象

> 简介

```go
1 go 没有面向对象语法等的要求
2 go 语言对于面向对象的设计非常简单而优雅
3 没有封装(数据更加安全)、继承、多态的概念，但是通过自定义也可以实现
```

> 匿名字段

```go
go 支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段
```























