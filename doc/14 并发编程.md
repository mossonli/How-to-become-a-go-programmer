## 并发编程

### 并发VS并行

```go
并行：在同一时刻，有多条指令在多个CPU处理器上同时执行
并发：在同一时刻，只能有一条指令执行，但多个进程指令被快速地轮换执行
```

### go语言的并发优势

```go
go语言在底层就支持了并发
简化了并发程序的编写
```

### goroutine 是什么

```go
它是go并发设计的核心
goroutine就是协程，它比线程更小，十几个goroutine在底层可能就是五六个线程
go语言内部实现了goroutine的内存共享，执行goroutine只需极少的栈内存(大概是4~5KB)
```

### 创建goroutine

```go
package main

import (
   "fmt"
   "time"
)

// 用于测试协程
func newTask() {
   i := 0
   for {
      i++
      fmt.Printf("new goroutine: i = %d\n", i)
      time.Sleep(time.Second)
   }
}

func main() {
   // 子协程调用方法
   go newTask()
   i := 0
   for {
      i++
      fmt.Printf("main goroutine: i = %d\n", i)
      time.Sleep(time.Second)
   }
}
```

>  如果主协程退出了，其他任务还执行吗？(不执行)

```go
package main

import (
   "fmt"
   "time"
)

func main() {
   // 合起来写
   go func() {
      i := 0
      for {
         i++
         fmt.Printf("new goroutine: i = %d\n", i)
         time.Sleep(time.Second)
      }
   }()
   //i := 0
   //for {
   // i++
   // fmt.Printf("main goroutine: i = %d\n", i)
   // time.Sleep(time.Second)
   // if i == 2 {
   //    break
   // }
   //}
   for{}
}
```

### runtime包

```go
runtime.Gosched()：让出CPU时间片，重新等待安排任务
runtime.Goexit()，退出当前协程
runtime.GOMAXPROCS()，设置跑程序的CPU核数
```

`runtime.Gosched()`

```go
package main

import (
	"fmt"
	"runtime"
)

func main()  {
	go func(s string) {
		for i:=0;i<2;i++{
			fmt.Println(s)
		}
	}("world")
	for i:=0;i<10;i++{
		// 切换成其他任务去执行
		runtime.Gosched()
		fmt.Println("hello", i)
	}
}
```

`runtime.Goexit()`

```go
package main

import (
   "fmt"
   "runtime"
)

func main() {
   go func() {
      defer fmt.Println("A.defer")
      func() {
         defer fmt.Println("B.defer")
         // 结束协程
         runtime.Goexit()
         defer fmt.Println("C.defer")
         fmt.Println("B")
      }()
      fmt.Println("A")
   }()
   for {
   }
}
B.defer
A.defer
// 如果不加 runtime.Goexit()
/*
B
B.defer
A
A.defer
*/
```

`runtime.GOMAXPROCS()` 设置跑程序用到的cpu的核心数

```go

```

